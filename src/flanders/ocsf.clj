(ns flanders.ocsf
  (:require [flanders.core :as f]
            [cheshire.core :as json]
            [clojure.string :as str]
            [clj-http.client :as client]
            [clojure.java.io :as io]
            flanders.types)
  (:import [flanders.types IntegerType NumberType StringType]))

;; :caption => title
;; all maps are closed
;; :observable => seems to be a class id
(defn- parse-attribute [[k {:strs [description requirement enum type is_array caption]}]
                       _opts]
  (let [f (case type
            "account" (f/str)
            "actor" (f/str)
            "affected_code" (f/str)
            "boolean_t" (f/bool)
            "datetime_t" (f/str)
            "email_t" (f/str)
            "file_hash_t" (f/str)
            "file_name_t" (f/str)
            "float_t" (f/num)
            "hostname_t" (f/str)
            "integer_t" (f/int)
            "ip_t" (f/str)
            "json_t" f/any ;https://github.com/ocsf/ocsf-schema/issues/950
            "long_t" (f/int)
            "mac_t" (f/str)
            "object_t" (f/map [(f/entry f/any f/any :required? false)])
            "port_t" (f/int)
            "process_name_t" (f/str)
            "string_t" (f/str)
            "subnet_t" (f/str)
            "timestamp_t" (f/int)
            "url_t" (f/str)
            "user" (f/str)
            "username_t" (f/str)
            "uuid_t" (f/str)
            (throw (ex-info (str "Unknown type: " (pr-str type)) {})))
        f (if enum
            (cond
              (instance? IntegerType f) (assoc f :values (mapv Long/parseLong (keys enum)))
              (instance? NumberType f) (assoc f :values (mapv Double/parseDouble (keys enum)))
              (instance? StringType f) (assoc f :values (mapv str (keys enum)))
              :else (throw (ex-info (str "enum on " (clojure.core/type f)) {})))
            f)
        f (cond-> f
            is_array f/seq-of)]
    (f/entry (keyword k) f
             :description (or description caption)
             :required? (case requirement "required" true ("recommended" "optional" nil) false))))

(defn ocsf-schema->flanders
  "Converts parsed OCSF schemas to Flanders.

  Example:
  https://schema.ocsf.io/api/1.3.0/classes/file_activity"
  ([v] (ocsf-schema->flanders v nil))
  ([{:strs [attributes description]} opts]
   (-> (f/map (mapv #(parse-attribute % opts)
                    (sort-by key attributes)))
       (assoc :description description))))

(def known-json-schema-url->ocsf-schema-url-translators
  (sorted-map "https://schema.ocsf.io" (fn [s]
                                         ;;TODO https://schema.ocsf.io/1.3.0/schema/ => https://schema.ocsf.io/1.3.0/api/
                                         (when (str/starts-with? s "https://schema.ocsf.io/schema/")
                                           (str/replace-first s "/schema/" "/api/")))))

(defn json-schema-url->ocsf-schema-url
  ([id] (json-schema-url->ocsf-schema-url id nil))
  ([id {::keys [ocsf-json-schema-url-translator]}]
   (let [ocsf-json-schema-url-translator (into known-json-schema-url->ocsf-schema-url-translators
                                               ocsf-json-schema-url-translator)]
     (or (some #(% id) (vals ocsf-json-schema-url-translator))
         (throw (ex-info (str "Unsupported JSON Schema id: " id) {}))))))

(comment
  #_ ;;TODO
  (assert (= "https://schema.ocsf.io/1.4.0-dev/schema/classes/security_finding"
             (json-schema-url->ocsf-schema-url "https://schema.ocsf.io/1.4.0-dev/schema/classes/security_finding")))
  (assert (= "https://schema.ocsf.io/api/1.4.0-dev/classes/security_finding"
             (json-schema-url->ocsf-schema-url "https://schema.ocsf.io/schema/1.4.0-dev/classes/security_finding")))
  (assert (= "https://schema.ocsf.io/api/classes/security_finding"
             (json-schema-url->ocsf-schema-url "https://schema.ocsf.io/schema/classes/security_finding")))
  )

(defn json-schema->json-schema-url
  "Returns the url corresponding to the provided OCSF JSON Schema url.
  Assumes JSON Schema was generated by https://github.com/ocsf/ocsf-server
  and hence uses $id for the url.
  
  Example:
  (json-schema->json-schema-url {\"$id\" \"https://schema.ocsf.io/schema/classes/security_finding\"
                                 \"title\": \"Security Finding\"
                                 \"type\": \"object\"})
  => \"https://schema.ocsf.io/schema/classes/security_finding\""
  [json-schema]
  (or (get json-schema "$id")
      (throw (ex-info "Could not infer OCSF schema url from JSON Schema object" {:json-schema json-schema}))))

(defn json-schema->ocsf-schema
  "Returns the OCSF schema corresponding to the provided JSON Schema."
  ([json-schema] (json-schema->ocsf-schema json-schema nil))
  ([json-schema {::keys [get-ocsf-schema] :as opts
                 :or {get-ocsf-schema (fn [url _opts] (-> url client/get :body json/decode))}}]
   (-> json-schema
       (json-schema->json-schema-url opts)
       (json-schema-url->ocsf-schema-url opts)
       get-ocsf-schema)))

(defn json-schema->flanders
  "Converts JSON Schema representing an OCSF entity into flanders
  by retrieving its OCSF schema via HTTP to the server named by $id.
  Assumes input was originally generated by https://github.com/ocsf/ocsf-server"
  ([json-schema] (json-schema->flanders json-schema nil))
  ([json-schema opts] (-> json-schema
                          (json-schema->ocsf-schema opts)
                          (ocsf-schema->flanders opts))))

#_
(defn schemas
  "Returns a map from OCSF identifier to Flanders schema for the given version.

  Example:
  (schemas \"v1.3.0\")
  => 
  {\"https://schema.ocsf.io/1.3.0/classes/patch_state\" #flanders.types.MapType{...}
  ...}"
  ([version] (schemas version nil))
  ([version opts]
   (case version
     "v1.3.0" (let [base-id "https://schema.ocsf.io/1.3.0/"
                    {:strs [classes types objects base_event]} (json/decode (slurp (io/resource "flanders/impl/ocsf-1.3.0-export.json")))]
                (-> {}
                    (assoc (str base-id "classes/base_event") (ocsf-schema->flanders base_event opts))
                    (into (map (fn [[n t]] [(str base-id "classes/" n) (ocsf-schema->flanders t opts)])) classes)
                    (into (map (fn [[n t]] [(str base-id "types/" n) (ocsf-schema->flanders t opts)])) types)
                    (into (map (fn [[n t]] [(str base-id "objects/" n) (ocsf-schema->flanders t opts)])) objects)))
     (throw (ex-info (str "Unsupported OCSF version " version) {})))))
