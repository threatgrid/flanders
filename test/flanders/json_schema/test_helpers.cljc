(ns flanders.json-schema.test-helpers
  (:require [clojure.walk :as walk]
            [schema-tools.walk :as stw]
            [flanders.json-schema :as fjs]
            [clojure.pprint :as pp]
            [flanders.schema :as schema]
            [flanders.malli :as malli]
            [malli.core :as m]
            [clojure.java.io :as io]
            [schema.core :as s]))

(defn ->malli [v] (malli/->malli (fjs/->flanders v nil) nil))
(defn ->schema [v] (#?(:clj schema/->schema+clean :default schema/->schema) (fjs/->flanders v nil) nil))

(defn unqualify-vars [vs]
  (let [gs (group-by namespace (sort (map symbol vs)))
        pad (count (str (max 1 (dec (count gs)))))]
    (into (sorted-map)
          (map-indexed (fn [i [_ v]]
                         (into {} (map #(vector % (symbol (format (str "ns-%0" pad "d") i) (-> % symbol name))))
                               v)))
          (into (sorted-map) gs))))

(defn vars-from-distinct-namespaces [n]
  (let [vars-from-different-namespaces (set (take n (keep #(-> (ns-publics %) first second) (all-ns))))]
    (assert (= n (count vars-from-different-namespaces)))
    (assert (or (empty? vars-from-different-namespaces)
                (apply distinct? (map #(-> % symbol namespace) vars-from-different-namespaces))))
    (assert (every? var? vars-from-different-namespaces))
    vars-from-different-namespaces))

(defn syms-from-distinct-namespaces [n]
  (mapv #(symbol (str "sym" % (str (random-uuid))) (str (random-uuid))) (range n)))

(defn collect-recursive-vars-from-schema [s]
  (let [vars (atom #{})]
    (stw/postwalk (fn [s]
                    (when (instance? schema.core.Recursive s)
                      (swap! vars conj (:derefable s)))
                    s)
                  s)
    @vars))

(defn collect-transitive-recursive-vars-from-schema [s]
  (loop [seen #{}
         remaining (collect-recursive-vars-from-schema s)]
    (if-some [v (first remaining)]
      (if (seen v)
        (recur seen (disj remaining v))
        (recur (conj seen v) (into (disj remaining v) (-> v deref collect-recursive-vars-from-schema))))
      seen)))

(defn unqualify-recursive-vars-from-schema-explain
  ([s] (unqualify-recursive-vars-from-schema-explain s (unqualify-vars (collect-recursive-vars-from-schema s))))
  ([s rename]
   (walk/postwalk (fn [v]
                    (if (and (seq? v)
                             (= 2 (count v))
                             (= 'var (first v))
                             (qualified-symbol? (second v)))
                      ;;unqualify recursive vars
                      (let [vsym (second v)]
                        (list 'var (or (rename vsym) (throw (ex-info (str "Unknown var " (pr-str vsym)) {:rename rename})))))
                      v))
                  (s/explain s))))

(defn pprint-reproducibly [v]
  (let [v (walk/postwalk (fn [v]
                           (cond
                             (s/optional-key? v) v
                             (s/required-key? v) v
                             (map? v) (into (sorted-map-by (fn [l r]
                                                             (cond
                                                               (and (seq? l) (seq? r)) (compare (vec l) (vec r))
                                                               (or (and (seq? l) (not (seqable? r)))
                                                                   (and (not (seqable? l)) (seq? r))) (compare (str (class l)) (str (class r)))
                                                               :else (compare l r))))
                                            v)
                             (set? v) (into (sorted-set) v)
                             :else v))
                         v)]
    (binding [*print-level* nil
              *print-length* nil
              *print-namespace-maps* false]
      (pp/pprint v))))

(defn explain-transitive-schema [s]
  (let [transitive-var->uniquified (unqualify-vars (collect-transitive-recursive-vars-from-schema s))]
    {:schema (unqualify-recursive-vars-from-schema-explain s transitive-var->uniquified)
     :vars (into {} (map (fn [[v uniq]]
                           [uniq (unqualify-recursive-vars-from-schema-explain @(find-var v) transitive-var->uniquified)]))
                 transitive-var->uniquified)}))

(defn generate-expected-schema-results [file nsym s]
  (let [f (io/file file)]
    (io/make-parents f)
    (spit f (with-out-str
              (println ";; generated by flanders.json-schema-test/generate-expected-schema-results")
              (pprint-reproducibly (list 'ns nsym))
              (pprint-reproducibly
                (list 'def (symbol "expected-schema-explain")
                      (list 'quote
                            (unqualify-recursive-vars-from-schema-explain s))))
              (let [transitive-var->uniquified (unqualify-vars (collect-transitive-recursive-vars-from-schema s))]
                (pprint-reproducibly
                  (list 'def (symbol "expected-transitive-defschema-vars")
                        (list 'quote
                              (set (vals transitive-var->uniquified)))))
                (pprint-reproducibly
                  (list 'def 'transitive-schema-atom `(atom (sorted-map))))
                (doseq [[v uniq] transitive-var->uniquified]
                  (pprint-reproducibly
                    `(swap! ~'transitive-schema-atom assoc '~uniq
                            '~(unqualify-recursive-vars-from-schema-explain @(find-var v)))))
                (pprint-reproducibly
                  (list 'def 'expected-transitive-schema-explains
                        (list `deref 'transitive-schema-atom)))
                )
              ))
    (require nsym :reload)))

(defn generate-example-malli [file json]
  (let [f (io/file file)]
    (io/make-parents f)
    (spit f (binding [*print-level* nil
                      *print-length* nil
                      *print-namespace-maps* false]
              (with-out-str (pp/pprint (m/form (->malli json nil))))))))

;; examples

(def example-security-finding
  {:severity_id 0,
   :category_uid 10,
   :status_id 0,
   :data_sources ["string"],
   :api {:operation "foo"} ,
   :unmapped {} ,
   :class_name "string",
   :osint [],
   :type_uid 10,
   :start_time_dt "string",
   :impact_score 10,
   :impact_id 0,
   :enrichments [],
   :nist ["string"],
   :cloud {:provider "foo"} ,
   :time 10,
   :evidence "anything",
   :process {} ,
   :start_time 10,
   :risk_level "string",
   :observables [],
   :risk_score 10,
   :time_dt "string",
   :duration 10,
   :state "string",
   :class_uid 10,
   :kill_chain [],
   :end_time 10,
   :category_name "string",
   :analytic {:type_id 0} ,
   :activity_name "string",
   :confidence_score 10,
   :timezone_offset 10,
   :status "string",
   :count 10,
   :severity "string",
   :cis_csc [],
   :status_detail "string",
   :end_time_dt "string",
   :status_code "string",
   :attacks [],
   :finding {:title "foo" :uid "foo"} ,
   :raw_data "string",
   :confidence "string",
   :activity_id 0,
   :resources [],
   :type_name "string",
   :confidence_id 0,
   :impact "string",
   :metadata {:product {:vendor_name "asdf"} :version "foo"} ,
   :compliance {:standards []},
   :message "string",
   :vulnerabilities [],
   :malware [],
   :state_id 0,
   :risk_level_id 0})

(def union-example
  {:$id "something"
   :title "union", ;;TODO
   :type "object",
   :properties (sorted-map
                 :x {:anyOf [{:type "integer"} {:type "string"}]}
                 :y {:type "integer"}),
   :required [:x :y]})
