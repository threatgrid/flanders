(ns flanders.json-schema.test-helpers
  (:require [clojure.walk :as walk]
            [schema-tools.walk :as stw]
            [clojure.pprint :as pp]
            [clojure.java.io :as io]
            [schema.core :as s]))

(defn unqualify-vars [vs]
  (let [gs (group-by namespace (sort (map symbol vs)))
        pad (count (str (max 1 (dec (count gs)))))]
    (into (sorted-map)
          (map-indexed (fn [i [_ v]]
                         (into {} (map #(vector % (symbol (format (str "ns-%0" pad "d") i) (-> % symbol name))))
                               v)))
          (into (sorted-map) gs))))

(defn vars-from-distinct-namespaces [n]
  (let [vars-from-different-namespaces (set (take n (keep #(-> (ns-publics %) first second) (all-ns))))]
    (assert (= n (count vars-from-different-namespaces)))
    (assert (or (empty? vars-from-different-namespaces)
                (apply distinct? (map #(-> % symbol namespace) vars-from-different-namespaces))))
    (assert (every? var? vars-from-different-namespaces))
    vars-from-different-namespaces))

(defn syms-from-distinct-namespaces [n]
  (mapv #(symbol (str "sym" % (str (random-uuid))) (str (random-uuid))) (range n)))

;; walks s/explain, schema walk might be more accurate
(defn collect-recursive-vars-from-schema [s]
  (let [vars (atom #{})]
    (stw/postwalk (fn [s]
                    (when (instance? schema.core.Recursive s)
                      (swap! vars conj (:derefable s)))
                    s)
                  s)
    @vars))

(defn unqualify-recursive-vars-from-schema-explain [s]
  (let [vs (collect-recursive-vars-from-schema s)
        rename (unqualify-vars vs)]
    (walk/postwalk (fn [v]
                     (if (and (seq? v)
                              (= 2 (count v))
                              (= 'var (first v))
                              (qualified-symbol? (second v)))
                       ;;unqualify recursive vars
                       (let [vsym (second v)]
                         (list 'var (or (rename vsym) (throw (ex-info (str "Unknown var " vsym) {:rename rename})))))
                       v))
                   (s/explain s))))

;; walks s/explain, schema walk might be more accurate
(defn collect-transitive-recursive-vars-from-schema [s]
  (loop [seen #{}
         remaining (collect-recursive-vars-from-schema s)]
    (if-some [v (first remaining)]
      (recur (cond-> seen
               (not (seen v)) (-> (conj v)
                                  (into (-> v deref collect-recursive-vars-from-schema))))
             (disj remaining v))
      seen)))

(defn pprint-reproducibly [v]
  (let [v (walk/postwalk (fn [v]
                           (cond
                             (s/optional-key? v) v
                             (s/required-key? v) v
                             (map? v) (into (sorted-map-by (fn [l r]
                                                             (cond
                                                               (and (seq? l) (seq? r)) (compare (vec l) (vec r))
                                                               (or (and (seq? l) (not (seqable? r)))
                                                                   (and (not (seqable? l)) (seq? r))) (compare (str (class l)) (str (class r)))
                                                               :else (compare l r))))
                                            v)
                             (set? v) (into (sorted-set) v)
                             :else v))
                         v)]
    (binding [*print-level* nil
              *print-length* nil
              *print-namespace-maps* false]
      (pp/pprint v))))

(defn generate-expected-schema-results [file nsym s]
  (let [f (io/file file)]
    (io/make-parents f)
    (spit f (with-out-str
              (println ";; generated by flanders.json-schema-test/generate-expected-schema-results")
              (pprint-reproducibly (list 'ns nsym))
              (pprint-reproducibly
                (list 'def (symbol "expected-schema-explain")
                      (list 'quote
                            (unqualify-recursive-vars-from-schema-explain s))))
              (let [transitive-var->uniquified (unqualify-vars (collect-transitive-recursive-vars-from-schema s))]
                (pprint-reproducibly
                  (list 'def (symbol "expected-transitive-defschema-vars")
                        (list 'quote
                              (set (vals transitive-var->uniquified)))))
                (pprint-reproducibly
                  (list 'def 'transitive-schema-atom `(atom (sorted-map))))
                (doseq [[v uniq] transitive-var->uniquified]
                  (pprint-reproducibly
                    `(swap! ~'transitive-schema-atom assoc '~uniq
                            '~(unqualify-recursive-vars-from-schema-explain @(find-var v)))))
                (pprint-reproducibly
                  (list 'def 'expected-transitive-schema-explains
                        (list `deref 'transitive-schema-atom)))
                )
              ))
    (require nsym :reload)))

(comment
  (generate-expected-schema-results "test/flanders/json_schema/test_helpers_schema_security_finding.clj"
                                    'flanders.json-schema.test-helpers-schema-security-finding
                                    @SchemaSecurityFinding)
  )
